using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace PyWin32Metadata
{
    public class ParsedInterface : ParsedType
    {
        private readonly List<ParsedMethod> _methods = new();

        public ParsedInterface((string, string) fullName, (string, string) baseFullName)
            : base(fullName)
        {
            BaseFullName = baseFullName;
        }

        public (string, string) BaseFullName { get; }
        public ParsedInterface? BaseInterface { get; set; }
        public IList<ParsedMethod> Methods => _methods;

        public IEnumerable<ParsedInterface> AllInterfaces
        {
            get
            {
                if (IsUnknown || IsDispatch)
                    yield break;

                if (BaseInterface != null)
                {
                    foreach (var bi in BaseInterface.AllInterfaces)
                    {
                        yield return bi;
                    }
                }
                yield return this;
            }
        }

        public string GatewayName
        {
            get
            {
                if (IsUnknown || IsDispatch)
                    return "PyGatewayBase";

                if (Name.StartsWith("I"))
                    return "PyG" + Name.Substring(1);

                return "PyG" + Name;
            }
        }

        public string GenerateCppDeclaration()
        {
            using var writer = new StringWriter();
            using var iw = new IndentedTextWriter(writer);
            GenerateCppDeclaration(iw);
            return writer.ToString();
        }

        public void GenerateCppDeclaration(IndentedTextWriter writer)
        {
            if (writer == null)
                throw new ArgumentNullException(nameof(writer));

            if (BaseInterface == null)
                throw new InvalidOperationException();

            writer.WriteLine($"// This file declares the {Name} Interface and Gateway for Python.");
            writer.WriteLine($"// Generated by {GetType().Namespace}");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Interface Declaration");
            writer.WriteLine();
            writer.WriteLine($"class Py{Name} : public Py{BaseInterface.Name} {{");
            writer.Indent++;
            writer.WriteLine("public:");
            writer.Indent++;
            writer.WriteLine($"MAKE_PYCOM_CTOR(Py{Name});");
            writer.WriteLine($"static {Name} *GetI(PyObject *self);");
            writer.WriteLine("static PyComTypeObject type;");
            writer.WriteLine();
            writer.WriteLine("// The Python methods");
            foreach (var method in Methods)
            {
                writer.WriteLine($"static PyObject *{method.Name}(PyObject *self, PyObject *args);");
            }

            writer.WriteLine();
            writer.Indent--;
            writer.WriteLine("protected:");
            writer.Indent++;
            writer.WriteLine($"Py{Name}(IUnknown *pdisp);");
            writer.WriteLine($"~Py{Name}();");
            writer.Indent--;
            writer.Indent--;
            writer.WriteLine("};");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Gateway Declaration");
            writer.WriteLine();
            writer.WriteLine($"class {GatewayName} : public {BaseInterface.GatewayName}, public {Name} {{");
            writer.Indent++;
            writer.WriteLine("protected:");
            writer.WriteLine($"{GatewayName}(PyObject *instance) : {BaseInterface.GatewayName}(instance) {{ ; }}");
            writer.WriteLine($"PYGATEWAY_MAKE_SUPPORT2({GatewayName}, {Name}, __uuidof({Name}), {BaseInterface.GatewayName})");
            writer.WriteLine();
            writer.Indent++;
            foreach (var bi in AllInterfaces)
            {
                writer.WriteLine($"// {bi.Name}");
                foreach (var method in bi.Methods)
                {
                    if (method.ReturnType == null)
                        throw new InvalidOperationException();

                    var parameters = string.Join(", ", method.Parameters.Select(p => p.GenerateCppMethodSignature()));
                    if (method.ReturnType.IsHRESULT)
                    {
                        writer.WriteLine($"STDMETHOD({method.Name})({parameters});");
                    }
                    else
                    {
                        writer.WriteLine($"STDMETHOD_({method.ReturnType.CppName}, {method.Name})({parameters});");
                    }
                    writer.WriteLine();
                }
            }
            writer.Indent--;
            writer.Indent--;
            writer.WriteLine("};");
        }

        public string GenerateCppImplementation()
        {
            using var writer = new StringWriter();
            using var iw = new IndentedTextWriter(writer);
            GenerateCppImplementation(iw);
            return writer.ToString();
        }

        public void GenerateCppImplementation(IndentedTextWriter writer)
        {
            if (writer == null)
                throw new ArgumentNullException(nameof(writer));

            if (BaseInterface == null)
                throw new InvalidOperationException();

            writer.WriteLine($"// This file implements the {Name} Interface and Gateway for Python.");
            writer.WriteLine($"// Generated by {GetType().Namespace}");
            writer.WriteLine();
            writer.WriteLine("#include \"shell_pch.h\"");
            foreach (var bi in AllInterfaces)
            {
                writer.WriteLine($"#include \"Py{bi.Name}.h\"");
            }
            writer.WriteLine();
            writer.WriteLine("// @doc - This file contains autoduck documentation");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Interface Implementation");
            writer.WriteLine($"Py{Name}::Py{Name}(IUnknown *pdisp):");
            writer.Indent++;
            writer.WriteLine($"Py{BaseInterface.Name}(pdisp)");
            writer.Indent--;
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("ob_type = &type;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"Py{Name}::~Py{Name}()");
            writer.WriteLine("{");
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"/* static */ {Name} *Py{Name}::GetI(PyObject *self)");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"return ({Name} *)Py{BaseInterface.Name}::GetI(self);");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            foreach (var method in Methods)
            {
                writer.WriteLine($"// @pymethod |Py{Name}|{method.Name}|Description of {method.Name}.");
                writer.WriteLine($"PyObject *Py{Name}::{method.Name}(PyObject *self, PyObject *args)");
                writer.WriteLine("{");
                writer.Indent++;
                var ptr = "pi";
                writer.WriteLine($"{Name} *{ptr} = GetI(self);");
                writer.WriteLine($"if ( {ptr} == NULL )");
                writer.Indent++;
                writer.WriteLine("return NULL;");
                writer.Indent--;
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();
            }

            writer.WriteLine($"// @object Py{Name}|Description of the interface");
            writer.WriteLine($"static struct PyMethodDef Py{Name}_methods[] =");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var method in Methods)
            {
                writer.WriteLine($"{{ \"{method.Name}\", Py{Name}::{method.Name}, 1 }}, // @pymeth {method.Name}|Description of {method.Name}");
            }
            writer.WriteLine("{ NULL }");
            writer.Indent--;
            writer.WriteLine("};");
            writer.WriteLine();
            writer.WriteLine($"PyComTypeObject Py{Name}::type(\"Py{Name}\",");
            writer.Indent++;
            writer.WriteLine($"&Py{BaseInterface.Name}::type,");
            writer.WriteLine($"sizeof(Py{Name}),");
            writer.WriteLine($"Py{Name}_methods,");
            writer.WriteLine($"GET_PYCOM_CTOR(Py{Name}));");
            writer.Indent--;
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Gateway Implementation");
            foreach (var method in Methods)
            {
                if (method.ReturnType == null)
                    throw new InvalidOperationException();

                var parameters = string.Join(", ", method.Parameters.Select(p => p.GenerateCppMethodSignature()));
                var sig = $"{Name}::{method.Name}({parameters})";
                if (method.ReturnType.IsHRESULT)
                {
                    writer.WriteLine($"STDMETHODIMP {sig}");
                }
                else
                {
                    writer.WriteLine($"STDMETHODIMP_({method.ReturnType.Name}) {sig}");
                }
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("PY_GATEWAY_METHOD;");

                var outs = 0;
                string formatChars = null;
                string codePost = null;
                string codePre = null;
                string codeVars = null;
                string argStr = null;
                foreach (var p in method.Parameters)
                {
                    if (p.Type == null)
                        throw new InvalidOperationException();

                    if (p.IsOut)
                    {
                        outs++;
                        if (p.Type.Indirections == 2)
                        {
                            writer.WriteLine($"if ({p.Name}==NULL) return E_POINTER;");
                        }
                    }
                    else
                    {
                        var cvt = ArgFormatter.GetArgConverter(p);
                        if (cvt == null)
                        {
                            writer.WriteLine($"// *** The input argument {p.Name} of type \"{p.Type.FullNameString}\" was not processed ***");
                            writer.WriteLine($"//   - Please ensure this conversion function exists, and is appropriate");
                            writer.WriteLine($"PyObject *ob{p.Name} = PyObject_From{p.Type.Name}({p.Name});");
                            writer.WriteLine($"if (ob{p.Name}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                            codePost += $"Py_DECREF(ob{p.Name});";
                            formatChars += "O";
                            argStr += $", ob{p.Name}";
                        }
                        else
                        {
                        }
                    }
                }

                string resStr;
                if (outs > 0)
                {
                    writer.WriteLine("PyObject *result;");
                    resStr = "&result";
                }
                else
                {
                    resStr = "NULL";
                }

                string fullArgStr;
                if (formatChars != null)
                {
                    fullArgStr = $"{resStr}, \"{formatChars}\"{argStr}";
                }
                else
                {
                    fullArgStr = resStr;
                }

                writer.WriteLine($"HRESULT hr=InvokeViaPolicy(\"{method.Name}\", {fullArgStr});");

                if (outs > 0)
                {
                    writer.WriteLine("if (FAILED(hr)) return hr;");
                    writer.WriteLine("// Process the Python results, and convert back to the real params");

                    formatChars = null;
                    string codePobjects = null;
                    string argsParseTuple = null;
                    foreach (var p in method.Parameters)
                    {
                        if (p.IsOut)
                        {
                        }
                    }

                    if (formatChars != null)
                    {
                        string parseFn;
                        if (formatChars.Length == 1)
                        {
                            parseFn = "PyArg_Parse";
                        }
                        else
                        {
                            parseFn = "PyArg_ParseTuple";
                        }

                        if (codePobjects != null)
                        {
                            writer.WriteLine(codePobjects);
                        }

                        writer.WriteLine($"if (!{parseFn}(result, \"{formatChars}\" {argsParseTuple}))");
                        writer.Indent++;
                        writer.WriteLine($"return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                        writer.Indent--;
                    }

                    if (codePost != null)
                    {
                        writer.WriteLine("BOOL bPythonIsHappy = TRUE;");
                        writer.WriteLine(codePost);
                        writer.WriteLine($"if (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                    }

                    writer.WriteLine("Py_DECREF(result);");
                }

                writer.WriteLine("return hr;");
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();
            }
        }
    }
}
