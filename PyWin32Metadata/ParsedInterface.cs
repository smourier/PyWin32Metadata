using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace PyWin32Metadata
{
    public class ParsedInterface : ParsedType
    {
        private readonly List<ParsedMethod> _methods = new();

        public ParsedInterface((string, string) fullName, (string, string) baseFullName)
            : base(fullName)
        {
            BaseFullName = baseFullName;
        }

        public (string, string) BaseFullName { get; }
        public ParsedInterface? BaseInterface { get; set; }
        public IList<ParsedMethod> Methods => _methods;

        public IEnumerable<ParsedInterface> AllInterfaces
        {
            get
            {
                if (IsUnknown || IsDispatch)
                    yield break;

                if (BaseInterface != null)
                {
                    foreach (var bi in BaseInterface.AllInterfaces)
                    {
                        yield return bi;
                    }
                }
                yield return this;
            }
        }

        public string GatewayName
        {
            get
            {
                if (IsUnknown || IsDispatch)
                    return "PyGatewayBase";

                if (Name.StartsWith("I"))
                    return "PyG" + Name.Substring(1);

                return "PyG" + Name;
            }
        }

        public string PointerName
        {
            get
            {
                var sb = new StringBuilder("p");
                foreach (var c in Name)
                {
                    if (c >= 'a' && c <= 'z')
                        continue;

                    sb.Append(c);
                }
                return sb.ToString();
            }
        }

        public string GenerateCppDeclaration(GeneratorContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            using var writer = new StringWriter();
            using var iw = new IndentedTextWriter(writer);
            GenerateCppDeclaration(context, iw);
            return writer.ToString();
        }

        public void GenerateCppDeclaration(GeneratorContext context, IndentedTextWriter writer)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            if (writer == null)
                throw new ArgumentNullException(nameof(writer));

            if (BaseInterface == null)
                throw new InvalidOperationException();

            writer.WriteLine($"// This file declares the {Name} Interface and Gateway for Python.");
            writer.WriteLine($"// Generated by {GetType().Namespace}");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Interface Declaration");
            writer.WriteLine();
            writer.WriteLine($"class Py{Name} : public Py{BaseInterface.Name} {{");
            writer.Indent++;
            writer.WriteLine("public:");
            writer.Indent++;
            writer.WriteLine($"MAKE_PYCOM_CTOR(Py{Name});");
            writer.WriteLine($"static {Name} *GetI(PyObject *self);");
            writer.WriteLine("static PyComTypeObject type;");
            writer.WriteLine();
            writer.WriteLine("// The Python methods");
            foreach (var method in Methods)
            {
                writer.WriteLine($"static PyObject *{method.Name}(PyObject *self, PyObject *args);");
            }

            writer.WriteLine();
            writer.Indent--;
            writer.WriteLine("protected:");
            writer.Indent++;
            writer.WriteLine($"Py{Name}(IUnknown *pdisp);");
            writer.WriteLine($"~Py{Name}();");
            writer.Indent--;
            writer.Indent--;
            writer.WriteLine("};");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Gateway Declaration");
            writer.WriteLine();
            writer.WriteLine($"class {GatewayName} : public {BaseInterface.GatewayName}, public {Name} {{");
            writer.Indent++;
            writer.WriteLine("protected:");
            writer.WriteLine($"{GatewayName}(PyObject *instance) : {BaseInterface.GatewayName}(instance) {{ ; }}");
            writer.WriteLine($"PYGATEWAY_MAKE_SUPPORT2({GatewayName}, {Name}, __uuidof({Name}), {BaseInterface.GatewayName})");
            writer.WriteLine();
            writer.Indent++;
            foreach (var bi in AllInterfaces)
            {
                writer.WriteLine($"// {bi.Name}");
                foreach (var method in bi.Methods)
                {
                    if (method.ReturnType == null)
                        throw new InvalidOperationException();

                    var parameters = string.Join(", ", method.Parameters.Select(p => p.GenerateCppMethodSignature()));
                    if (method.ReturnType.IsHRESULT)
                    {
                        writer.WriteLine($"STDMETHOD({method.Name})({parameters});");
                    }
                    else
                    {
                        writer.WriteLine($"STDMETHOD_({method.ReturnType.CppName}, {method.Name})({parameters});");
                    }
                    writer.WriteLine();
                }
            }
            writer.Indent--;
            writer.Indent--;
            writer.WriteLine("};");
        }

        public string GenerateCppImplementation(GeneratorContext context)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            using var writer = new StringWriter();
            using var iw = new IndentedTextWriter(writer);
            GenerateCppImplementation(context, iw);
            return writer.ToString();
        }

        public void GenerateCppImplementation(GeneratorContext context, IndentedTextWriter writer)
        {
            if (context == null)
                throw new ArgumentNullException(nameof(context));

            if (writer == null)
                throw new ArgumentNullException(nameof(writer));

            if (BaseInterface == null)
                throw new InvalidOperationException();

            writer.WriteLine($"// This file implements the {Name} Interface and Gateway for Python.");
            writer.WriteLine($"// Generated by {GetType().Namespace}");
            writer.WriteLine();
            writer.WriteLine("#include \"shell_pch.h\"");
            foreach (var bi in AllInterfaces)
            {
                writer.WriteLine($"#include \"Py{bi.Name}.h\"");
            }
            writer.WriteLine();
            writer.WriteLine("// @doc - This file contains autoduck documentation");
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Interface Implementation");
            writer.WriteLine($"Py{Name}::Py{Name}(IUnknown *pdisp):");
            writer.Indent++;
            writer.WriteLine($"Py{BaseInterface.Name}(pdisp)");
            writer.Indent--;
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine("ob_type = &type;");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"Py{Name}::~Py{Name}()");
            writer.WriteLine("{");
            writer.WriteLine("}");
            writer.WriteLine();
            writer.WriteLine($"/* static */ {Name} *Py{Name}::GetI(PyObject *self)");
            writer.WriteLine("{");
            writer.Indent++;
            writer.WriteLine($"return ({Name} *)Py{BaseInterface.Name}::GetI(self);");
            writer.Indent--;
            writer.WriteLine("}");
            writer.WriteLine();
            foreach (var method in Methods)
            {
                writer.WriteLine($"// @pymethod |Py{Name}|{method.Name}|Description of {method.Name}.");
                writer.WriteLine($"PyObject *Py{Name}::{method.Name}(PyObject *self, PyObject *args)");
                writer.WriteLine("{");
                writer.Indent++;
                var ptr = PointerName;
                writer.WriteLine($"{Name} *{ptr} = GetI(self);");
                writer.WriteLine($"if ( {ptr} == NULL )");
                writer.Indent++;
                writer.WriteLine("return NULL;");
                writer.Indent--;

                string? argsParseTuple = null;
                string? argsCOM = null;
                string? formatChars = null;
                var codePost = new List<string>();
                var codePythonObjects = new List<string>();
                var codeCppObjects = new List<string>();
                var cleanup = new List<string>();
                var cleanup_gil = new List<string>();

                foreach (var p in method.Parameters)
                {
                    var cvt = ArgFormatter.GetArgConverter(context, p);
                    if (cvt == null)
                    {
                        writer.WriteLine($"// *** The input argument {p.Name} of type \"{p.Type.Name}\" was not processed ***");
                        writer.WriteLine("//     Please check the conversion function is appropriate and exists!");
                        writer.WriteLine($"{p.Type.Name} {p.Name};");
                        writer.WriteLine($"PyObject *ob{p.Name};");
                        writer.WriteLine($"// @pyparm <o Py{p.Type.Name}>|{p.Name}||Description for {p.Name}");
                        codePost.Add($"if (bPythonIsHappy && !PyObject_As{p.Type.Name}( ob{p.Name}, &{p.Name} )) bPythonIsHappy = FALSE;");
                        formatChars += "O";
                        argsParseTuple += $", &ob{p.Name}";
                        argsCOM += ", " + p.Name;
                        cleanup.Add($"PyObject_Free{p.Type.Name}({p.Name});");
                        continue;
                    }

                    if (!p.IsOut)
                    {
                        var val = cvt.GetFormatChar();
                        if (val != null)
                        {
                            writer.WriteLine(cvt.GetAutoduckString());
                            formatChars += val;
                            argsParseTuple += ", " + cvt.GetParseTupleArg();

                            foreach (var pat in cvt.DeclareParseArgTupleInputConverter())
                            {
                                codePythonObjects.Add(pat);
                            }

                            codePost.AddRange(cvt.GetParsePostCode());
                            foreach (var acl in cvt.GetInterfaceArgCleanup())
                            {
                                cleanup.Add(acl);
                            }

                            foreach (var acl in cvt.GetInterfaceArgCleanupGIL())
                            {
                                cleanup_gil.Add(acl);
                            }
                        }
                    }

                    var comArg = cvt.GetInterfaceCppObjectInfo();
                    if (comArg.Item2 != null)
                    {
                        codeCppObjects.Add(comArg.Item2 + ";");
                    }
                    argsCOM += ", " + comArg.Item1;
                }

                foreach (var po in codePythonObjects)
                {
                    writer.WriteLine(po);
                }

                foreach (var co in codeCppObjects)
                {
                    writer.WriteLine(co);
                }

                writer.WriteLine($"if ( !PyArg_ParseTuple(args, \"{formatChars}:{method.Name}\"{argsParseTuple}) )");
                writer.Indent++;
                writer.WriteLine("return NULL;");
                writer.Indent--;

                if (codePost.Count > 0)
                {
                    var needsHappy = codePost.Any(p => p.Contains("bPythonIsHappy"));
                    if (needsHappy)
                    {
                        writer.WriteLine("BOOL bPythonIsHappy = TRUE;");
                    }

                    foreach (var cp in codePost)
                    {
                        writer.WriteLine(cp);
                    }

                    if (needsHappy)
                    {
                        writer.WriteLine("if (!bPythonIsHappy) return NULL;");
                    }
                }

                // REVIEW: this supposes the method always returns HRESULT. needs to check that
                writer.WriteLine("HRESULT hr;");
                writer.WriteLine("PY_INTERFACE_PRECALL;");
                writer.WriteLine($"hr = {ptr}->{method.Name}({(argsCOM != null ? argsCOM.Substring(1) : null)} );");
                foreach (var cl in cleanup)
                {
                    writer.WriteLine(cl);
                }
                writer.WriteLine("PY_INTERFACE_POSTCALL;");
                if (cleanup_gil.Count > 0)
                {
                    foreach (var cp in cleanup_gil)
                    {
                        writer.WriteLine(cp);
                    }
                }

                writer.WriteLine("if ( FAILED(hr) )");
                writer.Indent++;
                writer.WriteLine($"return PyCom_BuildPyException(hr, {ptr}, IID_{Name});");
                writer.Indent--;

                string? codePre = null;
                codePost.Clear();
                formatChars = null;
                var codeVarsPass = new List<string>();
                string? codeDecl = null;

                foreach (var p in method.Parameters)
                {
                    if (!p.IsOut)
                        continue;

                    var cvt = ArgFormatter.GetArgConverter(context, p);
                    if (cvt == null)
                    {
                        writer.WriteLine($"// *** The output argument {p.Name} of type \"{p.Type.Name}\" was not processed ***");
                        continue;
                    }

                    var formatChar = cvt.GetFormatChar();
                    if (formatChar != null)
                    {
                        formatChars += formatChar;
                        codePre += cvt.GetBuildForInterfacePreCode();
                        foreach (var cp in cvt.GetBuildForInterfacePostCode())
                        {
                            codePost.Add(cp);
                        }

                        var a = cvt.GetBuildValueArg();
                        if (a != null)
                        {
                            codeVarsPass.Add(a);
                        }

                        codeDecl += cvt.DeclareParseArgTupleInputConverter();
                    }
                }

                if (formatChars != null)
                {
                    if (codeDecl != null)
                    {
                        writer.WriteLine(codeDecl);
                    }

                    if (codePre != null)
                    {
                        writer.WriteLine(codePre);
                    }

                    writer.WriteLine($"PyObject *pyretval = Py_BuildValue(\"{formatChars}\", {string.Join(", ", codeVarsPass)});");
                    foreach (var cp in codePost)
                    {
                        writer.WriteLine(cp);
                    }
                    writer.WriteLine("return pyretval;");
                }
                else
                {
                    //writer.WriteLine("Py_INCREF(Py_None);");
                    //writer.WriteLine("return Py_None;");

                    writer.WriteLine($"// @rdesc The result is the HRESULT from the underlying {method.Name} call");
                    writer.WriteLine("return PyLong_FromLong(hr);");
                }

                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();
            }

            writer.WriteLine($"// @object Py{Name}|Description of the interface");
            writer.WriteLine($"static struct PyMethodDef Py{Name}_methods[] =");
            writer.WriteLine("{");
            writer.Indent++;
            foreach (var method in Methods)
            {
                writer.WriteLine($"{{ \"{method.Name}\", Py{Name}::{method.Name}, 1 }}, // @pymeth {method.Name}|Description of {method.Name}");
            }
            writer.WriteLine("{ NULL }");
            writer.Indent--;
            writer.WriteLine("};");
            writer.WriteLine();
            writer.WriteLine($"PyComTypeObject Py{Name}::type(\"Py{Name}\",");
            writer.Indent++;
            writer.WriteLine($"&Py{BaseInterface.Name}::type,");
            writer.WriteLine($"sizeof(Py{Name}),");
            writer.WriteLine($"Py{Name}_methods,");
            writer.WriteLine($"GET_PYCOM_CTOR(Py{Name}));");
            writer.Indent--;
            writer.WriteLine("// ---------------------------------------------------");
            writer.WriteLine("//");
            writer.WriteLine("// Gateway Implementation");
            foreach (var method in Methods)
            {
                if (method.ReturnType == null)
                    throw new InvalidOperationException();

                if (method.Name == "TranslateAccelerator")
                {
                }

                var parameters = string.Join(", ", method.Parameters.Select(p => p.GenerateCppMethodSignature()));
                var sig = $"PyG{Name}::{method.Name}({parameters})";
                if (method.ReturnType.IsHRESULT)
                {
                    writer.WriteLine($"STDMETHODIMP {sig}");
                }
                else
                {
                    writer.WriteLine($"STDMETHODIMP_({method.ReturnType.Name}) {sig}");
                }
                writer.WriteLine("{");
                writer.Indent++;
                writer.WriteLine("PY_GATEWAY_METHOD;");

                var outs = 0;
                string? formatChars = null;
                var codePost = new List<string>();
                var codePre = new List<string>();
                var codeVars = new List<string>();
                string? argStr = null;
                foreach (var p in method.Parameters)
                {
                    if (p.Type == null)
                        throw new InvalidOperationException();

                    if (p.IsOut)
                    {
                        outs++;
                        if (p.Type.Indirections == 2)
                        {
                            writer.WriteLine($"if ({p.Name}==NULL) return E_POINTER;");
                        }
                        continue;
                    }

                    var cvt = ArgFormatter.GetArgConverter(context, p);
                    if (cvt == null)
                    {
                        writer.WriteLine($"// *** The input argument {p.Name} of type \"{p.Type.Name}\" was not processed ***");
                        writer.WriteLine($"//   - Please ensure this conversion function exists, and is appropriate");
                        writer.WriteLine($"PyObject *ob{p.Name} = PyObject_From{p.Type.Name}({p.Name});");
                        writer.WriteLine($"if (ob{p.Name}==NULL) return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                        codePost.Add($"Py_DECREF(ob{p.Name});");
                        formatChars += "O";
                        argStr += $", ob{p.Name}";
                        continue;
                    }

                    cvt.GatewayMode = true;
                    var formatChar = cvt.GetFormatChar();
                    if (formatChar != null)
                    {
                        formatChars += formatChar;
                        foreach (var cp in cvt.DeclareParseArgTupleInputConverter())
                        {
                            codeVars.Add(cp);
                        }
                        argStr += ", " + cvt.GetBuildValueArg();
                    }

                    foreach (var cp in cvt.GetBuildForGatewayPreCode())
                    {
                        codePre.Add(cp);
                    }

                    foreach (var cp in cvt.GetBuildForGatewayPostCode())
                    {
                        codePost.Add(cp);
                    }
                }

                if (codeVars.Count > 0)
                {
                    foreach (var cp in codeVars)
                    {
                        writer.WriteLine(cp);
                    }
                }

                if (codePre.Count > 0)
                {
                    foreach (var cp in codePre)
                    {
                        writer.WriteLine(cp);
                    }
                }

                string resStr;
                if (outs > 0)
                {
                    writer.WriteLine("PyObject *result;");
                    resStr = "&result";
                }
                else
                {
                    resStr = "NULL";
                }

                string fullArgStr;
                if (formatChars != null)
                {
                    fullArgStr = $"{resStr}, \"{formatChars}\"{argStr}";
                }
                else
                {
                    fullArgStr = resStr;
                }

                writer.WriteLine($"HRESULT hr=InvokeViaPolicy(\"{method.Name}\", {fullArgStr});");
                if (codePost.Count > 0)
                {
                    foreach (var cp in codePost)
                    {
                        writer.WriteLine(cp);
                    }
                }

                if (outs > 0)
                {
                    writer.WriteLine("if (FAILED(hr)) return hr;");
                    writer.WriteLine("// Process the Python results, and convert back to the real params");

                    formatChars = null;
                    string? codePobjects = null;
                    string? argsParseTuple = null;
                    foreach (var p in method.Parameters)
                    {
                        if (!p.IsOut)
                            continue;

                        var cvt = ArgFormatter.GetArgConverter(context, p);
                        if (cvt == null)
                        {
                            writer.WriteLine($"// *** The output argument {p.Name} of type \"{p.Type.Name}\" was not processed ***");
                            continue;
                        }

                        cvt.GatewayMode = true;
                        var val = cvt.GetFormatChar();
                        if (val != null)
                        {
                            formatChars += val;
                            argsParseTuple += ", " + cvt.GetParseTupleArg();

                            codePobjects += cvt.DeclareParseArgTupleInputConverter();
                            codePost.AddRange(cvt.GetParsePostCode());
                        }
                    }

                    if (formatChars != null)
                    {
                        string parseFn;
                        if (formatChars.Length == 1)
                        {
                            parseFn = "PyArg_Parse";
                        }
                        else
                        {
                            parseFn = "PyArg_ParseTuple";
                        }

                        if (codePobjects != null)
                        {
                            writer.WriteLine(codePobjects);
                        }

                        writer.WriteLine($"if (!{parseFn}(result, \"{formatChars}\" {argsParseTuple}))");
                        writer.Indent++;
                        writer.WriteLine($"return MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                        writer.Indent--;
                    }

                    if (codePost.Count > 0)
                    {
                        var needsHappy = codePost.Any(p => p.Contains("bPythonIsHappy"));
                        if (needsHappy)
                        {
                            writer.WriteLine("BOOL bPythonIsHappy = TRUE;");
                        }

                        foreach (var cp in codePost)
                        {
                            writer.WriteLine(cp);
                        }

                        if (needsHappy)
                        {
                            writer.WriteLine($"if (!bPythonIsHappy) hr = MAKE_PYCOM_GATEWAY_FAILURE_CODE(\"{method.Name}\");");
                        }
                    }

                    writer.WriteLine("Py_DECREF(result);");
                }

                writer.WriteLine("return hr;");
                writer.Indent--;
                writer.WriteLine("}");
                writer.WriteLine();
            }
        }
    }
}
